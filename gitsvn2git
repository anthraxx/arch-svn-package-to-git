#!/bin/env python
import hashlib
import os
import shutil
import sys

from pathlib import Path
from subprocess import CalledProcessError, PIPE, run
from tempfile import NamedTemporaryFile
from typing import List, Tuple, Optional


class Style:
    """Common console styles."""

    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"


class Version:
    """Version information.

    Attributes:
        epoch (Optional[str]): epoch qualifier
        pkgver (str): primary version
        pkgrel (str): release fragment
    """

    def __init__(self, epoch: Optional[str], pkgver: str, pkgrel: str):
        self.epoch: Optional[str] = epoch
        self.pkgver: str = pkgver
        self.pkgrel: str = pkgrel

    @property
    def tag(self):
        if self.epoch:
            return f"release-{self.epoch}-{self.pkgver}-{self.pkgrel}"
        return f"release-{self.pkgver}-{self.pkgrel}"

    def __str__(self):
        if self.epoch:
            return f"{self.epoch}:{self.pkgver}-{self.pkgrel}"
        return f"{self.pkgver}-{self.pkgrel}"

    def __repr__(self):
        return str(self)


class Release:
    """Release information.

    Attributes:
        version (Version): version information.
        file_hash (str): PKGBUILD file hash.
        input_commit (str): commit of input git repository.
    """

    def __init__(self, version: Version, file_hash: str, input_commit: str):
        self.version: Version = version
        self.file_hash: str = file_hash
        self.input_commit: str = input_commit
        self.target_commit: Optional[str] = None

    def __repr__(self):
        return str(
            {
                "version": self.version,
                "file_hash": self.file_hash,
                "input_commit": self.input_commit,
                "target_commit": self.target_commit,
            }
        )


def debug2(message: str):
    """Pretty format second level debug message.

    Args:
        message (str): message to format.
    """
    if not os.environ.get('GITSVN2GIT_DEBUG'):
        return
    s = Style()
    print(f"{s.BOLD}{s.YELLOW}  ->{s.RESET}{s.BOLD} {message}{s.RESET}")


def debug3(message: str):
    """Pretty format third level debug message.

    Args:
        message (str): message to format.
    """
    if not os.environ.get('GITSVN2GIT_DEBUG'):
        return
    s = Style()
    print(f"{s.BOLD}{s.YELLOW}    ·>{s.RESET}{s.BOLD} {message}{s.RESET}")


def msg1(message: str):
    """Pretty format first level message.

    Args:
        message (str): message to format.
    """
    s = Style()
    print(f"{s.BOLD}{s.GREEN}==>{s.RESET}{s.BOLD} {message}{s.RESET}")


def msg2(message: str):
    """Pretty format second level message.

    Args:
        message (str): message to format.
    """
    s = Style()
    print(f"{s.BOLD}{s.BLUE}  ->{s.RESET}{s.BOLD} {message}{s.RESET}")


def msg3(message: str):
    """Pretty format third level message.

    Args:
        message (str): message to format.
    """
    s = Style()
    print(f"{s.BOLD}{s.YELLOW}    ·>{s.RESET}{s.BOLD} {message}{s.RESET}")


def error1(error: str):
    """Pretty format first level error message.

    Args:
        error (str): message to format.
    """
    s = Style()
    print(f"{s.BOLD}{s.RED}==>{s.RESET}{s.BOLD} {error}{s.RESET}")
    if os.environ.get('GITSVN2GIT_BREAKPOINT_ON_ERROR'):
        breakpoint()


def error2(error: str):
    """Pretty format 2nd level error message.

    Args:
        error (str): message to format.
    """
    s = Style()
    print(f"{s.BOLD}{s.RED}  ->{s.RESET}{s.BOLD} {error}{s.RESET}")
    if os.environ.get('GITSVN2GIT_BREAKPOINT_ON_ERROR'):
        breakpoint()


def warn2(warn: str):
    """Pretty format 2nd level warn message.

    Args:
        warn (str): message to format.
    """
    s = Style()
    print(f"{s.BOLD}{s.YELLOW}  ->{s.RESET}{s.BOLD} {warn}{s.RESET}")


def warn3(warn: str):
    """Pretty format 2nd level warn message.

    Args:
        warn (str): message to format.
    """
    s = Style()
    print(f"{s.BOLD}{s.YELLOW}    ·>{s.RESET}{s.BOLD} {warn}{s.RESET}")


def parse_input() -> Tuple[Path, Path, List[str]]:
    """Parse input arguments.

    Returns:
        tuple(Path, Path, list): input_dir, target_dir and list of packages.
    """
    if len(sys.argv) < 3:
        print(f"Usage: {__file__} INPUT_DIR TARGET_DIR [PACKAGE(s)]...")
        exit()

    input_dir = Path(sys.argv[1])
    if not input_dir.exists() or not input_dir.is_dir():
        error1(f"Input directory not found: {input_dir}")
        exit(1)
    if not (input_dir / 'packed-refs').exists() or (input_dir / 'index').exists():
        error1(f"Input directory not a bare git clone: {input_dir}")
        exit(1)

    package_refs: List[str] = []
    with open(input_dir / 'packed-refs', 'r') as f:
        for ref in f.read().splitlines():
            if 'refs/heads/packages/' not in ref:
                continue
            package_refs.append(ref.split()[1])

    packages = []
    if len(sys.argv) > 3:
        for package in sys.argv[3:]:
            if f'refs/heads/packages/{package}' not in package_refs:
                error1(f"Package ref not found: {package}")
                continue
            packages.append(package)
    else:
        packages = list(map(lambda path: Path(path).name, package_refs))

    target_dir = Path(sys.argv[2])
    target_dir.mkdir(exist_ok=True, parents=True)

    return input_dir, target_dir, packages


def clone_repository(input_dir: Path, package_dir: Path):
    """Clone input repository to target_dir.

    Args:
        input_dir (Path): input repository directory.
        package_dir (Path): package directory.
    """
    msg2("Cloning parent repository...")
    try:
        run(
            (
                f"git clone {input_dir} --no-local --branch packages/{package_dir.name}"
                f" --single-branch {package_dir}"
            ),
            check=True,
            shell=True,
        )
    except CalledProcessError as e:
        error1(f"Error cloning repository to {target_dir}...")
        raise e


def filter_subdirectory(package_dir: Path, subdirectory: Path) -> None:
    """Filter subdirectory in the package repository.

    Args:
        package_dir (Path): package directory.
        subdirectory (Path): subdirectory in the repository.
    """
    subdirectory = (package_dir / subdirectory).relative_to(package_dir)
    msg2(f"Filtering subdirectory '{subdirectory}'...")
    try:
        run(
            f"git-filter-repo --subdirectory-filter {subdirectory}",
            check=True,
            shell=True,
            cwd=package_dir,
        )
    except CalledProcessError as e:
        error1(f"Error filtering subdirectory '{subdirectory}'...")
        raise e


def get_version_from_pkgbuild(pkgbuild: bytes) -> Optional[Version]:
    """Extract version from the PKGBUILD content.

    Args:
        pkgbuild (bytes): PKGBUILD content.
    Returns:
        Optional[Version]: version information extracted from the PKGBUILD.
    """
    # It needs to generate a temporary file to be parsed in bash since it got
    # no direct access to PKGBUILD in the filesystem.
    with NamedTemporaryFile() as tmpfile:
        tmpfile.write(pkgbuild)
        tmpfile.flush()

        try:
            p = run(
                f"bash -c 'source {tmpfile.name} && printf \"%s\\n%s\\n%s\\n\" \"$epoch\" \"$pkgver\" \"$pkgrel\"'",
                check=True,
                shell=True,
                cwd=package_dir,
                stdout=PIPE,
                stderr=PIPE,
            )
            version_info: List[str] = p.stdout.decode().splitlines()
            epoch, pkgver, pkgrel = version_info
            return Version(epoch, pkgver, pkgrel)
        except CalledProcessError as e:
            warn3(f'PKGBUILD is not parsable: {e.stderr.decode()}')
            return None


def get_pkgbuild(package_dir: Path, file: str, commit: str) -> Optional[bytes]:
    """Get PKGBUILD content in an specific commit.

    Args:
        package_dir (Path): package directory.
        file (str): PKGBUILD file.
        commit (str): commit hash.

    Returns:
        Optional[bytes]: PKGBUILD content or None.
    """

    p = run(
        f"git show {commit}:{file}",
        cwd=package_dir,
        shell=True,
        stdout=PIPE,
        stderr=PIPE,
    )
    if p.returncode != 0:
        debug3(f'Cannot find PKGBUILD in {commit} - Skipping')
        return None

    debug3(f'reading PKGBUILD of commit {commit}')
    pkgbuild = p.stdout

    # Remove svn '# $Id$' since this will cause a md5sum mismatch
    pkgbuild = pkgbuild.replace(b"# $Id$\n", b"")

    # Remove expanded errorous svn '# $Id: '
    if pkgbuild_lines := pkgbuild.splitlines(keepends=True):
        if pkgbuild_lines[0].startswith(b'# $Id: PKGBUILD '):
            pkgbuild = b''.join(pkgbuild_lines[1:])

    return pkgbuild


def get_releases(
    package_dir: Path,
    grep: str = "archrelease: copy",
) -> List[Release]:
    """Get releases from the PKGBUILD filtering commit messages.

    Args:
        package_dir (Path): package directory.
        grep (str): string to be used in git grep.

    Returns:
        List[Release]: a list of the releases.
    """
    msg2("Parsing releases...")
    try:
        releases = []
        p = run(
            f"git log --pretty='%h %s' --grep='{grep}' -- repos",
            check=True,
            cwd=package_dir,
            shell=True,
            stdout=PIPE,
        )
        commits = p.stdout.decode().splitlines()
        for commit in commits:
            commit_hash, subject = commit.split(maxsplit=1)
            release_repos = subject.split('copy trunk to ')[1].split(', ')

            for release_repo in release_repos:
                pkgbuild_file = f'repos/{release_repo}/PKGBUILD'
                if pkgbuild := get_pkgbuild(package_dir, pkgbuild_file, commit_hash):
                    break

            if not pkgbuild:
                warn3(f"Error getting PKGBUILD from {commit_hash} - Skipping")
                continue

            md5 = hashlib.md5(pkgbuild)
            file_hash = md5.hexdigest()

            version = get_version_from_pkgbuild(pkgbuild)
            if not version:
                warn3(f'Error parsing PKGBUILD from {commit_hash} - Skipping')
                continue

            release = Release(version, file_hash, commit_hash)
            releases.append(release)

            debug3(f'Found release: {release}')
        return releases
    except CalledProcessError as e:
        error1("Error getting releases...")
        raise e


def rewrite_history(package_dir: Path):
    """Rewrite repository history and clean messages.

    Args:
        package_dir (Path): package directory.
    """
    msg2("Rewrite history...")
    try:
        mailmap_file = Path(__file__).parent / "AUTHORS"
        msg3("Remapping authors...")
        run(
            f"git-filter-repo --mailmap {mailmap_file.absolute()}",
            check=True,
            cwd=package_dir,
            shell=True,
            stdout=PIPE,
        )
        msg3("Remapping commiter to author...")
        run(
            (
                "git-filter-repo --commit-callback '"
                "commit.committer_name  = commit.author_name\n"
                "commit.committer_email = commit.author_email\n"
                "commit.committer_date  = commit.author_date'"
            ),
            check=True,
            cwd=package_dir,
            shell=True,
            stdout=PIPE,
        )
        msg3("Removing git-svn-id from commit messages...")
        run(
            (
                "git-filter-repo --message-callback "
                '\'return re.sub(b"\\ngit-svn-id.*\\n", b"", message)\''
            ),
            check=True,
            cwd=package_dir,
            shell=True,
            stdout=PIPE,
        )
        msg3("Removing '# $Id$' from PKGBUILD...")
        run(
            (
                "git-filter-repo --blob-callback "
                '\'blob.data = blob.data.replace(b"# $Id$\\n", b"")\''
            ),
            check=True,
            cwd=package_dir,
            shell=True,
            stdout=PIPE,
        )
    except CalledProcessError as e:
        error1("Error rewriting history...")
        raise e


def tag_releases(package_dir: Path, releases: List[Release]):
    """Generate git tags from the release objects.

    Args:
        package_dir (Path): package directory.
        releases (List[Release]): list of releases.
    """
    msg2("Tagging releases...")
    release_map = {}
    for release in releases:
        release_map[release.file_hash] = release

    released = {}
    try:
        p = run(
            "git log --pretty='%h'",
            check=True,
            cwd=package_dir,
            shell=True,
            stdout=PIPE,
        )
        commits = p.stdout.decode().splitlines()
        # Reverse tagging order to left the tag in the latest commit
        for commit in commits:
            pkgbuild = get_pkgbuild(package_dir, "PKGBUILD", commit)
            if not pkgbuild:
                continue

            md5 = hashlib.md5(pkgbuild)
            file_hash = md5.hexdigest()

            if file_hash not in release_map:
                continue

            release = release_map[file_hash]
            version = release.version

            run(
                f"git tag -f {version.tag} {commit} -m 'Package release {version}'",
                check=True,
                cwd=package_dir,
                shell=True,
            )
            release.target_commit = commit
            released[version.tag] = release
            debug3(f'Tagged {commit} for release {release}')
    except CalledProcessError as e:
        error1("Error tagging releases...")
        raise e

    for release in releases:
        if release.version.tag in released:
            continue
        error2(f"Failed to tag {release.version.tag} for version {release.version} with file-hash {release.file_hash} of input-commit {release.input_commit}")


def clean_up(package_dir: Path):
    """Clean up repository and run garbage collector.

    Args:
        package_dir (Path): package directory.
    """
    msg2("Cleaning up...")
    try:
        run("git branch -m master", cwd=package_dir, check=True, shell=True)

        shutil.rmtree(package_dir / ".git/refs/original", ignore_errors=True)
        shutil.rmtree(package_dir / ".git/refs/remotes", ignore_errors=True)
        shutil.rmtree(package_dir / ".git/logs", ignore_errors=True)

        run(
            (
                "git for-each-ref"
                ' --format="%(refname)" refs/original'
                " | xargs -n1 --no-run-if-empty git update-ref -d"
            ),
            check=True,
            cwd=package_dir,
            shell=True,
        )
        run(
            (
                "git -c gc.reflogExpire=0 -c gc.reflogExpireUnreachable=0"
                " -c gc.rerereresolved=0 -c gc.rerereunresolved=0"
                " -c gc.pruneExpire=now gc --aggressive"
            ),
            check=True,
            cwd=package_dir,
            shell=True,
        )
    except CalledProcessError as e:
        error1("Error cleaning up...")
        raise e


if __name__ == "__main__":
    input_dir, target_dir, packages = parse_input()
    msg1(f"Using input directory: {input_dir}")
    msg1(f"Using target directory: {target_dir}")

    for package in packages:
        msg1(f"Converting {package}...")

        package_dir = target_dir / package
        if package_dir.exists():
            msg2("Removing old checkout...")
            shutil.rmtree(package_dir)

        clone_repository(input_dir, package_dir)
        releases = get_releases(package_dir)
        filter_subdirectory(package_dir, Path("trunk"))
        rewrite_history(package_dir)
        tag_releases(package_dir, releases)
        clean_up(package_dir)
